# DNA序列编辑距离问题

## 题目描述

小R正在研究DNA序列，他需要编写一个函数来计算将一个受损DNA序列（dna1）转换成未受损序列（dna2）所需的最少编辑步骤。

可用的编辑操作包括：
1. 增加一个碱基
2. 删除一个碱基
3. 替换一个碱基

## 示例

```python
输入：dna1 = "AGT", dna2 = "AGCT"
输出：1
解释：只需要插入一个'C'即可

输入：dna1 = "AACCGGTT", dna2 = "AACCTTGG"
输出：4
解释：需要4步替换操作

输入：dna1 = "ACGT", dna2 = "TGC"
输出：3
解释：需要删除一个字符并替换两个字符
```

## 解题思路

这是一个经典的编辑距离（Levenshtein Distance）问题。我们可以使用动态规划来解决。

### 1. 动态规划状态定义

- 创建一个二维数组 `dp[i][j]`
- `dp[i][j]` 表示将 dna1 的前 i 个字符转换为 dna2 的前 j 个字符所需的最小操作次数

### 2. 状态转移方程

对于每个位置 (i,j)，我们需要考虑：

1. 如果当前字符相同（dna1[i-1] == dna2[j-1]）：
   ```python
   dp[i][j] = dp[i-1][j-1]  # 不需要任何操作
   ```

2. 如果当前字符不同，取三种操作中的最小值：
   ```python
   dp[i][j] = min(
       dp[i-1][j-1] + 1,  # 替换操作
       dp[i-1][j] + 1,    # 删除操作
       dp[i][j-1] + 1     # 插入操作
   )
   ```

### 3. 初始化

- 第一行：`dp[0][j]` 表示空串转换为长度为j的串需要的操作数（即j次插入）
- 第一列：`dp[i][0]` 表示长度为i的串转换为空串需要的操作数（即i次删除）

### 4. 代码实现

```python
def solution(dna1, dna2):
    # 创建动态规划矩阵
    m, n = len(dna1), len(dna2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化第一行和第一列
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # 填充dp矩阵
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if dna1[i-1] == dna2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j-1] + 1,  # 替换
                    dp[i-1][j] + 1,    # 删除
                    dp[i][j-1] + 1     # 插入
                )
    
    return dp[m][n]
```

## 复杂度分析

- 时间复杂度：O(mn)，其中 m 和 n 分别是两个DNA序列的长度
- 空间复杂度：O(mn)，需要一个二维数组来存储中间状态

## 示例解析

以 dna1 = "AGT", dna2 = "AGCT" 为例：

1. 初始状态：
```
  '' A G C T
'' 0 1 2 3 4
A  1
G  2
T  3
```

2. 经过动态规划填充后：
```
  '' A G C T
'' 0 1 2 3 4
A  1 0 1 2 3
G  2 1 0 1 2
T  3 2 1 1 1
```

3. 最终答案为 dp[3][4] = 1，表示只需要1步操作（在"GT"之间插入'C'）

## 总结

这道题是编辑距离问题的一个变体，通过动态规划可以高效地解决。关键点在于：

1. 正确定义状态转移方程
2. 处理好边界情况（初始化）
3. 理解三种操作（插入、删除、替换）对状态转移的影响

掌握这道题的解法对于理解动态规划的思想很有帮助，类似的问题还包括字符串匹配、序列对齐等。

