# 环形数组中的最大贡献值

## 题目描述

小S拿到了一个长度为 n 的环形数组，并定义了两个下标 i 和 j 的贡献值公式为：
```
f(i, j) = (a_i + a_j) * dist(i, j)
```
其中 `dist(i, j)` 是下标 i 和 j 在数组中的最短距离。小S希望找到一对下标，使得它们的贡献值尽可能大。环形数组的特点是最左和最右的元素也是相邻的。

## 输入格式

- n：数组长度
- a：环形数组

## 约束条件

- n >= 1
- 1 <= a[i] <= 1000

## 示例

### 示例1：
输入：n = 3, a = [1, 2, 3]
输出：5
解释：由于是环形数组，任意两个下标的距离都是1，因此 f(2,3) = (2 + 3) × 1 = 5。

### 示例2：
输入：n = 4, a = [4, 1, 2, 3]
输出：12

### 示例3：
输入：n = 5, a = [1, 5, 3, 7, 2]
输出：24

## 解题思路

1. **理解环形数组的特性**
   - 在环形数组中，任意两个位置之间都有两条路径：顺时针和逆时针
   - 需要取这两条路径中的较短距离作为 dist(i, j)

2. **计算距离**
   - 对于位置 i 和 j，顺时针距离为 `(j - i) % n`
   - 逆时针距离为 `(i - j) % n`
   - 取两者的最小值作为实际距离

3. **求解步骤**
   - 遍历所有可能的数对 (i, j)
   - 计算每对数的贡献值
   - 维护最大贡献值
   - 返回最终的最大值

## 代码实现

```python
def solution(n: int, a: list) -> int:
    def dist(i, j):
        # 计算环形数组中两点间的最短距离
        distance = min((i - j) % n, (j - i) % n)
        return (a[i] + a[j]) * distance
    
    max_contribution = 0
    
    # 遍历所有可能的数对
    for i in range(n):
        for j in range(i + 1, n):
            contribution = dist(i, j)
            max_contribution = max(max_contribution, contribution)
    
    return max_contribution
```

## 代码详解

1. **辅助函数 dist(i, j)**
   - 计算两个位置之间的最短距离
   - 使用取模运算处理环形特性
   - 返回根据公式计算的贡献值

2. **主函数逻辑**
   - 初始化最大贡献值为0
   - 使用两层循环遍历所有可能的数对
   - j 从 i+1 开始遍历，避免重复计算
   - 不断更新最大贡献值

3. **时间复杂度分析**
   - 两层循环遍历所有数对，时间复杂度为 O(n²)
   - 空间复杂度为 O(1)，只使用了常数额外空间

## 注意事项

1. 在计算距离时要考虑环形数组的特性
2. 不要忘记取两个方向距离的最小值
3. 注意数组下标的范围，避免越界
4. 考虑到题目给定的约束条件，确保输入合法

## 总结

这道题目主要考察了对环形数组特性的理解和处理。关键点在于：
1. 正确计算环形数组中两点间的最短距离
2. 理解并实现贡献值的计算公式
3. 通过遍历所有可能的数对来找到最大贡献值

通过这道题目，我们可以学习到环形数组的处理技巧，以及如何在循环结构中寻找最优解。