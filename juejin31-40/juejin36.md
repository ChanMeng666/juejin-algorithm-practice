# 最优点菜问题

## 题目描述

小C来到了一家饭馆，需要在满足特定条件的情况下选择最便宜的菜品组合。具体条件如下：

- 饭馆有n道菜，每道菜都有对应的价格a[i]
- 每道菜可能含有蘑菇，用字符串s表示（s[i]='1'表示第i道菜含蘑菇，'0'表示不含）
- 小C需要点k道菜
- 在所选的菜品中，最多只能有m道菜含有蘑菇
- 要求在满足上述条件的情况下，总价格最小

如果无法满足所有条件，则返回-1。

### 示例

```python
输入：s = "001", a = [10, 20, 30], m = 1, k = 2
输出：30
解释：选择前两道菜，总价格为30，且只有0道菜含蘑菇

输入：s = "111", a = [10, 20, 30], m = 1, k = 2
输出：-1
解释：所有菜都含蘑菇，无法只选1道含蘑菇的菜

输入：s = "0101", a = [5, 15, 10, 20], m = 2, k = 3
输出：30
解释：选择价格为5、10、15的三道菜，总价格为30
```

## 解题思路

这是一个组合优化问题，可以使用递归（回溯）的方式来解决。主要思路如下：

1. **基础判断**
   - 如果需要选择的菜品数量k大于总菜品数n，直接返回-1
   
2. **数据预处理**
   - 将菜品价格和是否含蘑菇的信息组合在一起
   - 按价格排序以提高效率

3. **递归求解**
   - 对于每道菜，我们有两个选择：选或不选
   - 使用递归函数计算最小总价格
   - 记录当前还需要选择的菜品数量和允许的蘑菇数量

4. **结果处理**
   - 如果找到合法解，返回最小总价格
   - 如果无法找到合法解，返回-1

## 代码实现

```python
def solution(s: str, a: list, m: int, k: int) -> int:
    n = len(s)  # 总菜品数
    
    if k > n:
        return -1
    
    # 将菜品信息整合到一起
    dishes = [(a[i], int(s[i])) for i in range(n)]
    
    def get_min_price(curr_dishes, curr_k, curr_m):
        if curr_k == 0:  # 已选够k个菜
            return 0
        if len(curr_dishes) < curr_k:  # 剩余菜品不够选
            return float('inf')
            
        # 不选第一个菜
        price1 = get_min_price(curr_dishes[1:], curr_k, curr_m)
        
        # 选第一个菜
        price2 = float('inf')
        if curr_dishes[0][1] <= curr_m:  # 如果蘑菇数量允许
            next_price = get_min_price(curr_dishes[1:], curr_k - 1, 
                                     curr_m - curr_dishes[0][1])
            if next_price != float('inf'):
                price2 = curr_dishes[0][0] + next_price
                
        return min(price1, price2)
    
    dishes.sort(key=lambda x: x[0])  # 按价格排序
    result = get_min_price(tuple(dishes), k, m)
    return result if result != float('inf') else -1
```

## 复杂度分析

- **时间复杂度**: O(2^n)
  - 每道菜都有选和不选两种可能
  - n为菜品总数
  
- **空间复杂度**: O(n)
  - 递归调用栈的深度最大为n
  - 需要存储菜品信息的列表

## 关键点解析

1. **递归函数设计**
   - 参数：当前可选菜品列表、还需选择的数量、剩余允许的蘑菇数量
   - 返回值：满足条件的最小总价格

2. **终止条件**
   - 已选够k个菜：返回0
   - 剩余菜品不够选：返回无穷大

3. **选择逻辑**
   - 不选当前菜品：直接跳过
   - 选择当前菜品：需要检查蘑菇数量限制

4. **优化方案**
   - 按价格排序可以提高剪枝效率
   - 使用tuple减少递归过程中的内存开销

## 注意事项

1. 输入参数的合法性检查
2. 无解情况的处理（返回-1）
3. 蘑菇数量的累计计算
4. 价格的累加和比较

## 相关题目

1. 背包问题
2. 组合优化问题
3. 递归与回溯类问题

