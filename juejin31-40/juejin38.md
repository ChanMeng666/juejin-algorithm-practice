# 旅行最优补给方案 - 动态规划详解

## 1. 问题描述

### 1.1 背景
小U计划进行一场从地点A到地点B的徒步旅行，需要解决旅途中的食物补给问题。

### 1.2 具体要求
- 旅行总共需要 `M` 天
- 每天都需要消耗一份食物
- 路途中会经过 `N` 个补给站
- 每个补给站的位置和食物价格已知
- 第0天（出发时）一定有一个补给站
- 补给站按时间顺序出现

### 1.3 目标
找到最优的购买策略，使得总花费最少，同时确保每天都有食物可用。

### 1.4 输入格式
- `M`：总路程天数（整数）
- `N`：补给站数量（整数）
- `p`：补给站信息列表，每个元素为 `[A, B]`
  - `A`：补给站出现的天数
  - `B`：该补给站每份食物的价格

### 1.5 示例
```python
# 示例1
输入：m = 5, n = 4, p = [[0, 2], [1, 3], [2, 1], [3, 2]]
输出：7

# 示例2
输入：m = 6, n = 5, p = [[0, 1], [1, 5], [2, 2], [3, 4], [5, 1]]
输出：6

# 示例3
输入：m = 4, n = 3, p = [[0, 3], [2, 2], [3, 1]]
输出：9
```

## 2. 解题思路

### 2.1 问题分析
1. **关键特点**
   - 每天必须有食物消耗
   - 可以在补给站购买多天的食物
   - 补给站的价格各不相同
   - 需要规划在哪些补给站购买多少食物

2. **决策过程**
   - 在每个补给站，需要决定是否购买食物
   - 如果购买，需要决定购买几天的份量
   - 购买决策会影响到后续天数的状态

### 2.2 动态规划设计

1. **状态定义**
   - 使用一维数组 `dp[i]` 表示到达第i天所需的最小花费
   - `i` 的范围是 [0, M]
   
2. **状态转移分析**
   - 当遇到补给站时，可以选择购买后续若干天的食物
   - 对于天数i的补给站，可以购买食物供应到任意后续天数j
   - 购买 (j-i) 份食物的花费为：(j-i) * price
   - 状态转移方程：`dp[j] = min(dp[j], dp[i] + (j-i) * price)`

3. **初始化**
   - dp[0] = 0：开始时没有花费
   - 其他位置初始化为无穷大

4. **最终结果**
   - dp[M] 即为所需的最小总花费

## 3. 代码实现

```python
def solution(m: int, n: int, p: list[list[int]]) -> int:
    """
    计算完成旅程所需的最小花费
    
    Args:
        m (int): 总路程天数
        n (int): 补给站数量
        p (list[list[int]]): 补给站信息，每个元素为 [天数, 价格]
    
    Returns:
        int: 最小花费
    """
    # 创建dp数组，dp[i]表示到达第i天所需的最小花费
    dp = [float('inf')] * (m + 1)
    
    # 记录补给站的位置和价格
    stations = {day: price for day, price in p}
    
    # 初始化第0天的状态
    dp[0] = 0
    
    # 动态规划过程
    for i in range(m):
        # 如果当前天数有补给站
        if i in stations:
            price = stations[i]
            # 从当前补给站买食物，可以支撑到之后的每一天
            for j in range(i + 1, m + 1):
                # dp[j]可以从dp[i]转移过来，需要购买(j-i)份食物
                dp[j] = min(dp[j], dp[i] + (j - i) * price)
    
    return dp[m]
```

## 4. 示例详解

让我们以示例1为例，详细分析解题过程：

输入：`m = 5, n = 4, p = [[0, 2], [1, 3], [2, 1], [3, 2]]`

**执行过程**：
1. 初始状态：
   - dp[0] = 0，其他位置为无穷大
   
2. 处理第0天补给站（价格=2）：
   - 可以购买1~5天的食物
   - dp[1] = min(∞, 0 + 1×2) = 2
   - dp[2] = min(∞, 0 + 2×2) = 4
   - dp[3] = min(∞, 0 + 3×2) = 6
   - dp[4] = min(∞, 0 + 4×2) = 8
   - dp[5] = min(∞, 0 + 5×2) = 10

3. 处理第1天补给站（价格=3）：
   - 可以购买1~4天的食物
   - dp[2] = min(4, 2 + 1×3) = 4
   - dp[3] = min(6, 2 + 2×3) = 6
   - dp[4] = min(8, 2 + 3×3) = 8
   - dp[5] = min(10, 2 + 4×3) = 10

4. 处理第2天补给站（价格=1）：
   - 可以购买1~3天的食物
   - dp[3] = min(6, 4 + 1×1) = 5
   - dp[4] = min(8, 4 + 2×1) = 6
   - dp[5] = min(10, 4 + 3×1) = 7

5. 处理第3天补给站（价格=2）：
   - 可以购买1~2天的食物
   - dp[4] = min(6, 5 + 1×2) = 6
   - dp[5] = min(7, 5 + 2×2) = 7

6. 最终结果：
   - dp[5] = 7 即为所需的最小花费

## 5. 总结

### 5.1 解题要点
1. **状态设计**
   - 选择合适的状态表示是解题的关键
   - 本题使用一维DP数组，简化了状态转移过程

2. **转移方程**
   - 清晰的转移方程保证了解题的正确性
   - 需要考虑所有可能的购买策略

3. **边界处理**
   - 正确的初始化确保了算法的起始条件
   - 合理的遍历范围避免了数组越界

### 5.2 扩展思考
1. 如果补给站的食物有数量限制，如何修改算法？
2. 如果食物有保质期限制，如何调整解题思路？
3. 如果允许在非补给站位置丢弃食物，会对结果有影响吗？

### 5.3 注意事项
1. 确保理解题目中的每个限制条件
2. 仔细处理动态规划中的边界情况
3. 注意数组初始化的默认值设置
4. 验证代码在各种测试用例下的表现