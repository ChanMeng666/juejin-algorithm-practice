# 最长可击败怪物序列

## 题目描述

小E在一个游戏中遇到了n个按顺序出现的怪物。每个怪物都有其特定的血量hi和攻击力ai。小E的初始血量为H，攻击力为A。游戏规则如下：

1. 小E可以击败血量和攻击力都小于她当前属性的怪物
2. 对于每只怪物，小E可以选择与它战斗或者跳过这只怪物
3. 为了保持战斗节奏，要求击败的怪物序列中，后一个怪物的血量和攻击力都必须严格大于前一个怪物

求小E最多能击败多少怪物。

### 输入格式
- n：怪物的数量
- H：小E的血量
- A：小E的攻击力
- h[i]：第i个怪物的血量
- a[i]：第i个怪物的攻击力

### 输出格式
返回小E最多能击败的怪物数量

### 约束条件
- 1 < n < 100
- 1 < H,A,h[i],a[i] < 1000

### 示例
**示例1:**
```
输入：n = 3, H = 4, A = 5, h = [1, 2, 3], a = [3, 2, 1]
输出：1
```

**示例2:**
```
输入：n = 5, H = 10, A = 10, h = [6, 9, 12, 4, 7], a = [8, 9, 10, 2, 5]
输出：2
```

**示例3:**
```
输入：n = 4, H = 20, A = 25, h = [10, 15, 18, 22], a = [12, 18, 20, 26]
输出：3
```

## 解题思路

这是一个典型的动态规划问题，我们需要考虑以下几点：

1. **状态定义**：
   - 使用dp[i]表示以第i个怪物结尾的最长可击败序列长度

2. **状态转移**：
   - 对于每个怪物i，首先判断是否可以击败它（血量和攻击力都要小于小E的属性）
   - 如果可以击败，则至少可以形成长度为1的序列
   - 然后查看之前的所有怪物j，如果：
     * j被击败了（dp[j] > 0）
     * 当前怪物的属性严格大于j的属性
     * 则可以将当前怪物接在j之后，形成更长的序列

3. **初始化**：
   - 初始化dp数组为全0
   - 当遇到可以击败的怪物时，将对应位置至少设为1

## 代码实现

```python
def solution(n: int, H: int, A: int, h: list, a: list) -> int:
    # 创建一个数组来存储以每个怪物结尾的最长可击败序列长度
    dp = [0] * n
    
    # 遍历每个怪物
    for i in range(n):
        # 如果当前怪物可以被击败
        if H > h[i] and A > a[i]:
            # 初始化为1，表示至少可以击败当前怪物
            dp[i] = 1
            # 检查之前的怪物
            for j in range(i):
                # 如果之前的怪物也被击败了，且满足序列要求
                if dp[j] > 0 and h[i] > h[j] and a[i] > a[j]:
                    # 更新最长序列长度
                    dp[i] = max(dp[i], dp[j] + 1)
    
    # 返回最长序列长度
    return max(dp) if any(dp) else 0
```

## 复杂度分析

- 时间复杂度：O(n²)，其中n是怪物的数量。需要两层循环遍历所有怪物。
- 空间复杂度：O(n)，需要一个长度为n的dp数组来存储状态。

## 示例详解

让我们以示例2为例，分析整个过程：
```
输入：n = 5, H = 10, A = 10, h = [6, 9, 12, 4, 7], a = [8, 9, 10, 2, 5]
```

1. 遍历第1个怪物(6,8)：
   - 可以击败，因为10>6且10>8
   - dp[0] = 1

2. 遍历第2个怪物(9,9)：
   - 可以击败，因为10>9且10>9
   - 检查前面的怪物：9>6且9>8
   - dp[1] = 2

3. 遍历第3个怪物(12,10)：
   - 不能击败，因为10<12
   - dp[2] = 0

4. 遍历第4个怪物(4,2)：
   - 可以击败，因为10>4且10>2
   - dp[3] = 1

5. 遍历第5个怪物(7,5)：
   - 可以击败，因为10>7且10>5
   - 检查前面的怪物：只能接在(4,2)后面
   - dp[4] = 2

最终返回dp数组中的最大值2。

## 总结

这道题目是动态规划中的最长递增子序列(LIS)问题的变体。主要的区别在于：
1. 需要先判断怪物是否可以被击败
2. 需要同时考虑两个属性（血量和攻击力）的严格递增

解决这类问题的关键是：
1. 正确定义状态
2. 找到状态之间的转移关系
3. 注意边界条件的处理
