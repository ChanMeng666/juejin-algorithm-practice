# 猫咪分鱼干问题

## 题目描述

在猫星球上，小R负责给一行排队的猫分发鱼干。每只猫都有一个等级值，需要按照以下规则分配鱼干：

1. 每只猫至少要得到1斤鱼干
2. 如果一只猫的等级比相邻的猫高，那么这只猫必须得到比相邻猫更多的鱼干

要求计算出满足上述条件的最少鱼干总数。

## 示例

### 示例1
输入：
- n = 3
- cats_levels = [1, 2, 2]

输出：4

解释：最优分配方案是 [1, 2, 1]
- 第一只猫分到1斤鱼干
- 第二只猫分到2斤鱼干（因为比第一只猫等级高）
- 第三只猫分到1斤鱼干（与第二只猫等级相同，可以少于第二只猫）

### 示例2
输入：
- n = 6
- cats_levels = [6, 5, 4, 3, 2, 16]

输出：17

解释：最优分配方案是 [4, 3, 2, 1, 1, 6]

## 解题思路

这是一个典型的贪心算法问题，我们可以通过两次遍历来解决：

1. 初始化
   - 首先给每只猫分配1斤鱼干，确保满足第一个条件

2. 从左向右遍历
   - 比较每只猫与其左边猫的等级
   - 如果当前猫的等级比左边的高，就给它比左边的猫多1斤鱼干
   - 这样确保了每只猫与左边相邻猫的关系是正确的

3. 从右向左遍历
   - 比较每只猫与其右边猫的等级
   - 如果当前猫的等级比右边的高，就需要确保它比右边的猫至少多1斤鱼干
   - 使用max操作来保证不破坏之前左遍历时确定的数量

4. 最后计算总和
   - 将所有猫获得的鱼干数量相加即为答案

## 代码实现

```python
def solution(n, cats_levels):
    # 初始化每只猫获得的鱼干数量为1
    candies = [1] * n
    
    # 从左向右遍历，确保等级高的猫比左边的猫获得更多鱼干
    for i in range(1, n):
        if cats_levels[i] > cats_levels[i-1]:
            candies[i] = candies[i-1] + 1
    
    # 从右向左遍历，确保等级高的猫比右边的猫获得更多鱼干
    for i in range(n-2, -1, -1):
        if cats_levels[i] > cats_levels[i+1]:
            candies[i] = max(candies[i], candies[i+1] + 1)
    
    # 返回所需的总鱼干数量
    return sum(candies)
```

## 复杂度分析

- 时间复杂度：O(n)，需要对数组进行两次遍历
- 空间复杂度：O(n)，需要一个额外数组存储每只猫获得的鱼干数量

## 易错点解析

1. 只做一次遍历是不够的
   - 如果只从左向右遍历，可能无法处理右边相邻关系
   - 如果只从右向左遍历，可能无法处理左边相邻关系

2. 第二次遍历时要使用max
   - 不能直接赋值candies[i] = candies[i+1] + 1
   - 需要保证不破坏第一次遍历建立的大小关系

3. 相同等级的处理
   - 当两只相邻的猫等级相同时，它们可以获得相同或不同数量的鱼干
   - 为了得到最小总数，相同等级的猫应该尽可能获得较少的鱼干

## 总结

这道题的核心在于：
1. 理解问题可以通过两次遍历来解决
2. 正确处理相邻关系和相等情况
3. 在保证规则的前提下最小化总数

掌握这道题对于理解贪心算法和处理相邻元素关系的问题很有帮助。
