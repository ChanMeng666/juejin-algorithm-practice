# 寻找班级中独特的数字卡片

## 题目描述

在一个班级中，每位同学都拿到了一张卡片，上面有一个整数。有趣的是，除了一个数字之外，所有的数字都恰好出现了两次。现在需要你帮助班长小C快速找到那个拿了独特数字卡片的同学手上的数字是什么。

### 要求
- 设计一个算法，使其时间复杂度为 O(n)，其中 n 是班级的人数
- 尽量减少额外空间的使用，以体现你的算法优化能力

### 约束条件
- 1 ≤ cards.length ≤ 1001
- 0 ≤ cards[i] ≤ 1000
- 班级人数为奇数
- 除了一个数字卡片只出现一次外，其余每个数字卡片都恰好出现两次

## 示例
```python
示例 1：
输入：cards = [1, 1, 2, 2, 3, 3, 4, 5, 5]
输出：4
解释：拿到数字 4 的同学是唯一一个没有配对的。

示例 2：
输入：cards = [0, 1, 0, 1, 2]
输出：2
解释：数字 2 只出现一次，是独特的卡片。

示例 3：
输入：cards = [7, 3, 3, 7, 10]
输出：10
解释：10 是班级中唯一一个不重复的数字卡片。
```

## 解题思路

这道题可以使用异或运算（XOR）来解决。异或运算有以下几个重要特性：

1. 任何数字与自己异或等于0：`a ^ a = 0`
2. 任何数字与0异或等于它本身：`a ^ 0 = a`
3. 异或运算满足交换律和结合律：
   - `a ^ b = b ^ a`
   - `(a ^ b) ^ c = a ^ (b ^ c)`

利用这些特性，我们可以：
1. 将所有数字依次进行异或运算
2. 相同的数字会两两抵消（变成0）
3. 最后剩下的就是只出现一次的数字

## 代码实现

```python
def solution(cards):
    # 使用异或运算找出唯一的数字
    result = 0
    for num in cards:
        result ^= num
    return result


if __name__ == "__main__":
    # 测试用例
    print(solution([1, 1, 2, 2, 3, 3, 4, 5, 5]) == 4)  # True
    print(solution([0, 1, 0, 1, 2]) == 2)  # True
    print(solution([7, 3, 3, 7, 10]) == 10)  # True
```

## 代码解释

让我们以示例1来详细说明代码的执行过程：
```python
cards = [1, 1, 2, 2, 3, 3, 4, 5, 5]
```

1. 初始化 `result = 0`
2. 依次进行异或运算：
   - `0 ^ 1 = 1`
   - `1 ^ 1 = 0`（第一个1被抵消）
   - `0 ^ 2 = 2`
   - `2 ^ 2 = 0`（2被抵消）
   - `0 ^ 3 = 3`
   - `3 ^ 3 = 0`（3被抵消）
   - `0 ^ 4 = 4`
   - `4 ^ 5 = 4 ^ 5`
   - `(4 ^ 5) ^ 5 = 4`（5被抵消）

最终得到结果4，这就是只出现一次的数字。

## 复杂度分析

- 时间复杂度：O(n)，其中n是数组长度。我们只需要遍历一次数组。
- 空间复杂度：O(1)，只使用了一个变量来存储结果。

## 总结

这道题展示了位运算在算法中的巧妙应用：
1. 使用异或运算可以在不使用额外空间的情况下找出只出现一次的数字
2. 代码简洁优雅，执行效率高
3. 这种解法在处理大规模数据时特别有优势

这个解法比传统的使用哈希表统计频次的方法更优，因为它不需要额外的存储空间，完美满足了题目对空间优化的要求。

