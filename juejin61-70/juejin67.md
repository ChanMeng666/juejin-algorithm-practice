# 猜数字游戏的获胜概率

## 题目描述

在一个数字游戏中，数字 1 到 n 中有一个是幸运数字，且这个数字是等概率随机选择的。玩家 小I 和 小W 轮流从这些数字中猜测幸运数字，小I 总是先开始猜。

游戏规则如下：
- 每轮游戏后，主持人会宣布猜测结果是太大了、太小了，还是正确的
- 如果猜中，那么该轮猜测者即为游戏的获胜者
- 两位玩家都采取最优策略

要求计算小I（先手）获胜的概率，并输出保留五位小数的结果。

## 示例

```python
输入：n = 2
输出：'0.50000'

输入：n = 3
输出：'0.66667'

输入：n = 4
输出：'0.50000'

输入：n = 5
输出：'0.60000'
```

## 解题思路

这是一个典型的博弈论问题，可以使用动态规划（记忆化搜索）来解决。

### 1. 核心思路

1. 对于任意区间 [left, right]，我们需要计算在该区间内先手玩家的最优获胜概率
2. 每个玩家在自己的回合都会选择使自己获胜概率最大的策略
3. 当一个玩家猜测某个数字时，有三种可能：
   - 猜中：直接获胜
   - 猜大了：继续在左边区间游戏
   - 猜小了：继续在右边区间游戏

### 2. 状态定义

- 使用 dp[(left, right)] 表示在区间 [left, right] 内先手玩家的最优获胜概率
- 使用记忆化搜索避免重复计算相同状态

### 3. 状态转移

对于当前区间 [left, right]：
1. 如果 left == right，说明只剩一个数字，必定猜中，概率为 1
2. 否则，遍历当前可以猜的每个数字 guess，计算选择该数字的获胜概率：
   - 猜中的概率：1/总数
   - 猜小了的概率：(right-guess)/总数 * (1-对手在右区间的获胜概率)
   - 猜大了的概率：(guess-left)/总数 * (1-对手在左区间的获胜概率)
3. 取所有可能选择中的最大概率作为最优策略

### 4. 代码实现要点

```python
def solution(n):
    dp = {}  # 记忆化存储
    
    def dfs(left, right):
        if left == right:  # 基础情况
            return 1
            
        if (left, right) in dp:  # 避免重复计算
            return dp[(left, right)]
            
        total = right - left + 1
        prob = 0
        
        # 遍历所有可能的猜测
        for guess in range(left, right + 1):
            curr_prob = 1.0 / total  # 猜中的概率
            
            # 处理猜小了的情况
            if guess > left:
                curr_prob += (guess - left) / total * (1 - dfs(left, guess - 1))
            # 处理猜大了的情况
            if guess < right:
                curr_prob += (right - guess) / total * (1 - dfs(guess + 1, right))
                
            prob = max(prob, curr_prob)  # 取最优策略
            
        dp[(left, right)] = prob
        return prob
        
    return '{:.5f}'.format(dfs(1, n))  # 格式化输出
```

## 复杂度分析

- 时间复杂度：O(n³)，其中n为数字范围。对于每个区间 [left, right]，需要遍历所有可能的猜测。
- 空间复杂度：O(n²)，主要是存储动态规划状态的空间消耗。

## 总结

这道题目是一个很好的博弈论和动态规划结合的例子。解题的关键在于：
1. 正确建立动态规划状态
2. 准确计算每种选择的概率
3. 利用记忆化搜索优化性能
4. 理解双方都采用最优策略的含义

通过这道题目，我们可以学习到如何处理概率相关的动态规划问题，以及如何在博弈过程中考虑双方的最优策略。
