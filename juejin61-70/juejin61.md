# 最优飞行路线问题

## 题目描述

小C和他的领导小F计划一次飞行，但由于严格的航空管制，他们的飞机仅能按特定的路线飞行。飞机只能飞往当前机场的相邻机场或相同航空公司管理的机场。为了减少起飞次数，小C需要制定最优的飞行路线。

### 具体规则
- 机场由一个数组airports标识，每个元素代表一个独特的机场，元素的值代表不同的航空公司
- airports[0]为起点，airports[airports.length - 1]为终点
- 如果当前在机场i，那么i-1和i+1（如果存在）代表邻近机场，飞机可以直接前往
- 如果在机场i，且存在airports[i] == airports[j]，则机场i和机场j同属一家航空公司，可直接飞往
- 求到达终点的最小起飞次数

### 示例
```python
示例1：
输入：airports = [10, 12, 13, 12, 14]
输出：3
解释：10 -> 12 -> 12 -> 14，需要3次起飞

示例2：
输入：airports = [10, 11, 12, 13, 14]
输出：4
解释：只能通过相邻机场逐个飞行，需要4次起飞

示例3：
输入：airports = [7, 7, 7, 8, 9, 7]
输出：1
解释：从第一个7直接飞到最后一个7，只需1次起飞
```

## 解题思路

### 1. 问题分析
这是一个典型的最短路径问题，我们需要找到从起点到终点的最少跳转次数。每个机场可以：
1. 飞往相邻的机场（左右各一个）
2. 飞往属于同一航空公司的其他机场

### 2. 解决方案
使用广度优先搜索(BFS)来解决这个问题，因为：
- BFS可以保证找到的第一条到达终点的路径就是最短路径
- 每次起飞相当于图中的一条边，我们要找的就是从起点到终点的最少边数

### 3. 具体实现步骤

1. 初始化：
   - 使用队列存储待访问的位置和对应的起飞次数
   - 使用集合记录已访问过的机场，避免重复访问

2. BFS主循环：
   - 从队列中取出当前位置和已用起飞次数
   - 如果到达终点，返回当前起飞次数
   - 否则，寻找所有可能的下一个机场：
     - 相邻的机场（如果存在）
     - 同一航空公司的其他机场

3. 对于每个可能的下一个机场：
   - 如果未访问过，则加入队列
   - 记录新的位置和增加后的起飞次数

### 4. 代码实现
```python
def solution(airports):
    from collections import deque
    n = len(airports)
    
    # 使用BFS查找最短路径
    queue = deque([(0, 0)])  # (位置, 起飞次数)
    visited = {0}  # 记录已访问的位置
    
    while queue:
        pos, flights = queue.popleft()
        
        # 如果到达终点，返回所需的起飞次数
        if pos == n - 1:
            return flights
            
        # 尝试所有可能的下一步移动
        next_positions = set()
        
        # 添加相邻机场
        if pos + 1 < n:
            next_positions.add(pos + 1)
        if pos - 1 >= 0:
            next_positions.add(pos - 1)
            
        # 添加同一航空公司的其他机场
        for i in range(n):
            if airports[i] == airports[pos] and i != pos:
                next_positions.add(i)
                
        # 遍历所有可能的下一步位置
        for next_pos in next_positions:
            if next_pos not in visited:
                visited.add(next_pos)
                queue.append((next_pos, flights + 1))
    
    return -1  # 如果无法到达终点
```

### 5. 复杂度分析
- 时间复杂度：O(n²)，其中n是机场数量。在最坏情况下，我们需要遍历所有机场来寻找同一航空公司的其他机场。
- 空间复杂度：O(n)，用于存储访问过的节点集合和队列。

### 6. 优化建议
- 如果需要处理更大规模的数据，可以预处理建立航空公司到机场的映射表，这样可以更快地找到同一航空公司的其他机场
- 可以使用双向BFS来进一步优化搜索效率

## 总结
这是一个结合了图论和搜索算法的经典问题。通过BFS可以有效地找到最短路径，而使用visited集合可以避免重复访问，从而提高效率。理解这个问题的解法对于掌握图搜索算法和最短路径问题很有帮助。

