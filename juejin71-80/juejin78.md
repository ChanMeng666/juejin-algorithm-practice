# 飞行棋棋子分组问题

## 题目描述

小M和小F在玩飞行棋。游戏结束后，他们需要将桌上的飞行棋棋子分组整理好。现在有 N 个棋子，每个棋子上有一个数字序号。小M的目标是将这些棋子分成若干组，要求：
1. 每组恰好包含5个棋子
2. 每组内的棋子序号必须完全相同

请判断是否可以按照上述规则完成分组。

## 示例

### 示例 1
输入：`nums = [1, 2, 3, 4, 5]`
输出：`"False"`
解释：虽然有5个棋子，但序号都不同，无法形成有效分组。

### 示例 2
输入：`nums = [1, 1, 1, 1, 2, 1, 2, 2, 2, 2]`
输出：`"True"`
解释：可以分成两组，第一组是5个1，第二组是5个2。

### 示例 3
输入：`nums = [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]`
输出：`"True"`
解释：可以分成两组，每组都是5个5。

## 解题思路

这道题可以通过以下步骤来解决：

1. **基本判断**
   - 首先检查棋子总数是否能被5整除
   - 如果不能被5整除，说明无法将所有棋子分成每组5个的组，直接返回"False"

2. **统计频次**
   - 使用字典统计每个数字出现的次数
   - 遍历输入数组，记录每个数字出现的频次

3. **验证分组**
   - 检查每个数字的出现次数是否都是5的倍数
   - 如果有任何一个数字的出现次数不是5的倍数，返回"False"
   - 如果所有数字的出现次数都是5的倍数，返回"True"

## 代码实现

```python
def solution(nums: list[int]) -> str:
    # 如果总数不能被5整除，直接返回False
    if len(nums) % 5 != 0:
        return "False"
    
    # 统计每个数字出现的次数
    count_dict = {}
    for num in nums:
        count_dict[num] = count_dict.get(num, 0) + 1
    
    # 检查每个数字的出现次数是否都是5的倍数
    for count in count_dict.values():
        if count % 5 != 0:
            return "False"
    
    return "True"
```

## 代码解释

1. `if len(nums) % 5 != 0:`
   - 首先检查输入数组的长度是否能被5整除
   - 这是必要的前提条件，因为每组必须恰好有5个棋子

2. `count_dict = {}`
   - 创建一个空字典用于统计每个数字的出现次数
   - 使用字典的好处是可以快速查找和更新数字的计数

3. `count_dict[num] = count_dict.get(num, 0) + 1`
   - 使用dict.get()方法安全地获取并更新计数
   - 如果数字不存在，默认值为0，然后加1
   - 如果数字已存在，获取当前计数并加1

4. 最后的检查循环
   - 遍历字典中所有的计数值
   - 检查每个计数是否能被5整除
   - 只要有一个不能被5整除，就返回"False"
   - 所有检查都通过才返回"True"

## 复杂度分析

- 时间复杂度：O(n)，其中n是输入数组的长度
  - 需要遍历一次数组来统计频次
  - 需要遍历一次字典来检查计数值
- 空间复杂度：O(k)，其中k是不同数字的个数
  - 需要一个字典来存储每个数字的出现次数

## 注意事项

1. 返回值是字符串类型的"True"或"False"，而不是布尔值
2. 输入数组的长度可能很大，但解法的时间复杂度是线性的，可以高效处理
3. 不需要实际进行分组，只需要判断是否可以分组

