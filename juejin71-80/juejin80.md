# 带冷冻期的股票交易最大收益问题

## 题目描述

小R近期表现出色，公司决定以股票的形式给予奖励，并允许他在市场上进行交易以最大化收益。给定一个数组，数组中的第 i 个元素代表第 i 天的股票价格。小R需要设计一个算法来实现最大利润。

### 交易规则
1. 可以多次买卖股票，但在买入新的股票前必须卖出之前的股票
2. 每次卖出股票后存在一天的冷冻期，在冷冻期内不能购买股票

### 输入输出说明
- 输入：stocks - 一个整数列表，表示连续几天内的股票价格
- 输出：能够获得的最大利润

### 示例
```python
示例1：
输入：stocks = [1, 2]
输出：1
解释：第一天买入，第二天卖出，获得利润 1

示例2：
输入：stocks = [2, 1]
输出：0
解释：股票价格下跌，不进行交易

示例3：
输入：stocks = [1, 2, 3, 0, 2]
输出：3
解释：
- 第一天买入，价格=1
- 第三天卖出，价格=3，利润=2
- 第四天是冷冻期
- 第五天买入，价格=2
- 第六天卖出，价格=2，总利润=3
```

## 解题思路

### 1. 问题分析
这是一个典型的动态规划问题。在每一天，我们的股票状态可能是以下三种之一：
1. 持有股票
2. 不持有股票，且处于冷冻期（刚卖出）
3. 不持有股票，且不处于冷冻期

### 2. 状态定义
我们用三个数组来记录到第i天为止的最大收益：
- hold[i]：第i天持有股票时的最大收益
- sold[i]：第i天卖出股票（进入冷冻期）的最大收益
- rest[i]：第i天不持有股票且不在冷冻期的最大收益

### 3. 状态转移方程
对于每一天i，状态转移如下：
1. hold[i] = max(hold[i-1], rest[i-1] - prices[i])
   - 可能来自前一天就持有股票
   - 或者前一天不持有且不在冷冻期，今天买入

2. sold[i] = hold[i-1] + prices[i]
   - 只能来自前一天持有股票，今天卖出

3. rest[i] = max(rest[i-1], sold[i-1])
   - 可能来自前一天也不持有且不在冷冻期
   - 或者前一天刚卖出（在冷冻期）

### 4. 初始状态
- hold[0] = -prices[0]：第一天买入股票
- sold[0] = 0：第一天不可能卖出股票
- rest[0] = 0：第一天不持有股票

### 5. 最终结果
最后一天的最大收益一定是不持有股票的状态，因此返回：
max(sold[n-1], rest[n-1])

## 代码实现
```python
def solution(stocks):
    if not stocks or len(stocks) < 2:
        return 0
        
    # 定义三个状态数组
    hold = [-float('inf')] * len(stocks)
    sold = [0] * len(stocks)
    rest = [0] * len(stocks)
    
    # 设置初始状态
    hold[0] = -stocks[0]
    
    # 状态转移
    for i in range(1, len(stocks)):
        hold[i] = max(hold[i-1], rest[i-1] - stocks[i])
        sold[i] = hold[i-1] + stocks[i]
        rest[i] = max(rest[i-1], sold[i-1])
    
    return max(sold[-1], rest[-1])
```

## 复杂度分析
- 时间复杂度：O(n)，其中n是股票价格数组的长度
- 空间复杂度：O(n)，使用了三个长度为n的数组来存储状态

## 优化思路
由于每一天的状态只依赖于前一天的状态，我们可以将空间复杂度优化到O(1)，只使用三个变量来记录前一天的状态。但为了代码的清晰度，这里保留了数组形式的实现。

