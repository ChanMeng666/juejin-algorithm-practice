# DNA序列编辑距离问题

## 题目描述

小U是一位古生物学家，正在研究不同物种之间的血缘关系。为了分析两种古生物的血缘远近，她需要比较它们的DNA序列。DNA由四种核苷酸A、C、G、T组成，并且可能通过三种方式发生变异：
1. 添加一个核苷酸
2. 删除一个核苷酸
3. 替换一个核苷酸

小U认为两条DNA序列之间的最小变异次数可以反映它们之间的血缘关系：变异次数越少，血缘关系越近。

### 输入
- dna1: 第一条DNA序列
- dna2: 第二条DNA序列

### 输出
- 返回将dna1转换为dna2所需的最小变异次数

## 解题思路

这是一个经典的编辑距离（Levenshtein Distance）问题的变体。我们可以使用动态规划来解决这个问题。

### 1. 动态规划状态定义

创建一个二维数组dp，其中：
- dp[i][j] 表示将dna1的前i个字符转换为dna2的前j个字符所需的最小操作次数

### 2. 状态转移方程

对于每个位置(i,j)，有以下情况：

1. 如果当前字符相同（dna1[i-1] == dna2[j-1]）：
   ```
   dp[i][j] = dp[i-1][j-1]
   ```

2. 如果当前字符不同，取三种操作中的最小值：
   ```
   dp[i][j] = min(
       dp[i-1][j-1] + 1,  # 替换操作
       dp[i-1][j] + 1,    # 删除操作
       dp[i][j-1] + 1     # 插入操作
   )
   ```

### 3. 初始化

- 第一行（i=0）：dp[0][j] = j（表示将空串变为长度为j的串需要j次插入）
- 第一列（j=0）：dp[i][0] = i（表示将长度为i的串变为空串需要i次删除）

### 4. 代码实现

```python
def solution(dna1, dna2):
    m, n = len(dna1), len(dna2)
    # 创建DP表格
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化第一行和第一列
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
        
    # 填充DP表格
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if dna1[i-1] == dna2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j-1] + 1,  # 替换
                    dp[i-1][j] + 1,    # 删除
                    dp[i][j-1] + 1     # 插入
                )
    
    return dp[m][n]
```

## 复杂度分析

- 时间复杂度：O(mn)，其中m和n分别是两个DNA序列的长度
- 空间复杂度：O(mn)，需要一个m+1行n+1列的二维数组存储中间状态

## 示例和解释

以输入 dna1 = "AGT", dna2 = "AGCT" 为例：

1. 初始状态：
```
   ''  A  G  C  T
'' 0  1  2  3  4
A  1
G  2
T  3
```

2. 最终的DP表格：
```
   ''  A  G  C  T
'' 0  1  2  3  4
A  1  0  1  2  3
G  2  1  0  1  2
T  3  2  1  1  1
```

最终答案为dp[3][4] = 1，表示需要1次操作（在"AG"和"T"之间插入"C"）。

## 常见测试用例

1. `dna1 = "AGT", dna2 = "AGCT"` → 输出：1
2. `dna1 = "AACCGGTT", dna2 = "AACCTTGG"` → 输出：4
3. `dna1 = "ACGT", dna2 = "TGC"` → 输出：3
4. `dna1 = "", dna2 = "ACGT"` → 输出：4
5. `dna1 = "GGGG", dna2 = "TTTT"` → 输出：4

## 注意事项

1. 处理空字符串的情况
2. 确保正确初始化DP表格的第一行和第一列
3. 在实现时注意数组索引的偏移（dp表格大小比字符串长度多1）
