# 还原原始字符串

## 题目描述

给定一个字符串 F，这个字符串是通过以下规则从某个初始字符串 S 构造得到的：

- 选择一个整数 K（其中 0 ≤ K < |S|，|S| 表示字符串 S 的长度）
- 将 S 从第 K 个位置（从0开始计数）到末尾的子串添加到 S 的末尾，即：S = S + S[K:]

现在给定最终的字符串 F，请找出可能的最短的初始字符串 S。

## 输入格式

- 输入为一个字符串，仅包含小写字母，长度不超过 1000。

## 输出格式

- 输出一个字符串，表示可能的最短的初始字符串 S。
- 如果无法通过题目描述的操作得到输入字符串，则输出原始字符串 F。

## 示例

### 示例1：
```
输入：str1 = "abbabbbabb"
输出："ab"
解释：初始字符串"ab"可以通过以下步骤得到最终字符串：
K = 1: "ab" → "abb"
K = 0: "abb" → "abbabb"
K = 2: "abbabb" → "abbabbbabb"
```

### 示例2：
```
输入：str1 = "abbbabbbb"
输出："ab"
```

## 解题思路

1. **基本思路**：
   - 从最短的可能长度开始尝试（从1开始），找到能够通过题目描述的操作构造出目标字符串的最短初始字符串。
   - 对于每个可能的初始字符串长度，我们取原字符串的前缀作为候选初始字符串。

2. **具体实现**：
   - 使用广度优先搜索(BFS)来尝试所有可能的操作序列。
   - 对于每个状态，尝试所有可能的K值（从0到当前字符串长度-1）。
   - 使用集合记录已经尝试过的中间状态，避免重复计算。
   - 确保每一步生成的字符串都是目标字符串的前缀。

3. **优化策略**：
   - 使用seen集合避免重复状态。
   - 限制操作步数不超过原字符串长度，防止无限循环。
   - 使用startswith检查确保生成的中间结果始终是目标字符串的前缀。

## 代码实现

```python
def solution(str1):
    # 从最短可能的子串开始尝试
    n = len(str1)
    for i in range(1, n + 1):
        # 获取前i个字符作为候选初始字符串
        candidate = str1[:i]
        current = candidate
        
        # 记录已经尝试过的字符串，避免循环
        seen = {current}
        queue = [(current, 0)]  # (当前字符串, 已使用的步数)
        
        while queue:
            current, steps = queue.pop(0)
            if current == str1:
                return candidate
                
            if steps >= n:  # 防止无限循环
                break
                
            # 尝试所有可能的K值
            for k in range(len(current)):
                # 从第k个位置开始的子串添加到末尾
                next_str = current + current[k:]
                if len(next_str) <= len(str1) and next_str not in seen and str1.startswith(next_str):
                    seen.add(next_str)
                    queue.append((next_str, steps + 1))
    
    return str1
```

## 复杂度分析

- **时间复杂度**：O(n²)，其中n是输入字符串的长度。对于每个可能的初始字符串长度，我们需要尝试多个操作步骤。
- **空间复杂度**：O(n)，主要用于存储队列和已访问状态的集合。

## 注意事项

1. 确保检查生成的字符串长度不超过目标字符串长度。
2. 使用startswith检查可以快速排除无效的操作路径。
3. 记录已访问状态可以显著减少重复计算。
4. 限制操作步数可以防止无限循环。

## 相关题目

- 字符串构造类问题
- 最短路径搜索问题

