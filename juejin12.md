# 最大UCC子串计数

## 问题描述

给定一个仅由字符'U'和'C'组成的字符串`s`，以及一个整数`m`。你的任务是通过最多`m`次编辑操作，找出能形成的最大"UCC"子串数量。

编辑操作可以是以下之一：
1. 在字符串的任意位置插入一个字符（'U'或'C'）
2. 从字符串中删除一个字符
3. 将字符串中的一个字符替换为另一个字符（'U'或'C'）

## 解决方案

这个问题的解决方案采用贪心算法。以下是高效解决此问题的Python代码：

```python
def solution(m: int, s: str) -> int:
    ls = s.split("UCC")
    ans = len(ls) - 1
    c1 = c2 = 0
    for s in ls:
        i = 0
        k = len(s)
        while i < k:
            if i + 1 < k and s[i + 1] == 'C':
                i += 2
                c1 += 1
            else:
                i += 1
                c2 += 1
    k1 = min(m, c1)
    m -= k1
    ans += k1
    k2 = min(m >> 1, c2)
    ans += k2
    m -= k2 * 2
    ans += m // 3
    return ans
```

## 解释

让我们逐步分解解决方案：

1. 首先，我们按"UCC"分割字符串`s`。`s`中已存在的"UCC"子串数量为`len(ls) - 1`。

2. 然后，我们遍历`ls`中的每个子串，统计两种模式：
   - `c1`：'UC'模式的数量（需要1次编辑变成"UCC"）
   - `c2`：单个字符的数量（需要2次编辑变成"UCC"）

3. 我们按以下顺序使用剩余的编辑次数`m`：
   - 将'UC'转换为"UCC"（每次花费1次编辑）
   - 将单个字符转换为"UCC"（每次花费2次编辑）
   - 从头创建新的"UCC"（每次花费3次编辑）

4. 我们计算：
   - `k1 = min(m, c1)`：我们能将多少个'UC'转换为"UCC"
   - `k2 = min(m >> 1, c2)`：我们能将多少个单个字符转换为"UCC"（m >> 1 等同于 m // 2）
   - 剩余的编辑次数`m // 3`：我们能从头创建多少个新的"UCC"

5. 最终答案是以下数量的总和：
   - 初始"UCC"数量
   - 由'UC'转换而来的"UCC"数量
   - 由单个字符转换而来的"UCC"数量
   - 从头创建的新"UCC"数量

这种贪心方法确保了我们能用给定的编辑次数最大化"UCC"子串的数量。

## 时间和空间复杂度

- 时间复杂度：O(n)，其中n是字符串`s`的长度
- 空间复杂度：O(n)，由于split操作

## 示例

让我们以例子：`s = "UCUUCCCCC"` 和 `m = 3` 为例

1. 按"UCC"分割：`ls = ["UC", "CCCCC"]`，`ans = 1`（初始计数）
2. 统计模式：
   - 在"UC"中：`c1 = 1`，`c2 = 0`
   - 在"CCCCC"中：`c1 = 2`，`c2 = 1`
   - 总计：`c1 = 3`，`c2 = 1`
3. 使用编辑：
   - 将3个'UC'转换为"UCC"：`k1 = min(3, 3) = 3`，`m = 0`
   - 没有剩余编辑次数用于其他操作
4. 最终计数：`1 + 3 = 4`

因此，可以形成的最大"UCC"子串数量为4。

这个解决方案能有效处理各种情况，并最佳地利用给定的编辑操作来最大化"UCC"子串计数。