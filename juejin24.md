# 特殊播放顺序问题

## 题目描述

小R设计了一个特殊的歌曲播放规则：
1. 首先播放歌单中的第一首歌，并将其从歌单中移除
2. 如果歌单中还有歌曲，则将当前第一首歌移到最后一首
3. 重复上述步骤，直到歌单中没有任何歌曲

要求：给定一个歌单（用数组表示，数组中的数字为歌曲ID），按照上述规则输出最终的播放顺序。

注意：保证歌曲ID两两不同。

### 示例

**示例 1:**
```
输入：n = 5, a = [5, 3, 2, 1, 4]
输出：[5, 2, 4, 1, 3]
```

**示例 2:**
```
输入：n = 4, a = [4, 1, 3, 2]
输出：[4, 3, 1, 2]
```

**示例 3:**
```
输入：n = 6, a = [1, 2, 3, 4, 5, 6]
输出：[1, 3, 5, 2, 6, 4]
```

## 解题思路

这是一个模拟题，我们需要按照给定的规则模拟整个播放过程。主要思路如下：

1. 使用双端队列（deque）来存储歌单，因为我们需要频繁进行队首和队尾的操作
2. 循环执行以下操作，直到队列为空：
   - 取出并播放队首的歌曲（加入结果列表）
   - 如果队列还不为空，则将新的队首歌曲移到队尾

### 为什么使用双端队列？

- Python的collections.deque提供了高效的队首和队尾操作
- popleft()操作的时间复杂度为O(1)
- append()操作的时间复杂度也为O(1)

### 具体实现步骤

1. 导入deque并将输入列表转换为双端队列
```python
from collections import deque
songs = deque(a)
```

2. 创建结果列表用于存储播放顺序
```python
result = []
```

3. 循环处理队列中的歌曲
```python
while songs:
    # 播放并移除第一首歌
    result.append(songs.popleft())
    
    # 如果队列不为空，将第一首歌移到末尾
    if songs:
        songs.append(songs.popleft())
```

4. 返回最终的播放顺序
```python
return result
```

## 复杂度分析

- 时间复杂度：O(n)，其中n为歌单长度。每首歌最多被操作两次（一次播放，一次可能移到末尾）
- 空间复杂度：O(n)，需要存储所有歌曲的播放顺序

## 完整代码

```python
def solution(n: int, a: list) -> list:
    from collections import deque
    songs = deque(a)
    result = []
    
    while songs:
        # 播放并移除第一首歌
        result.append(songs.popleft())
        
        # 如果队列不为空，将第一首歌移到末尾
        if songs:
            songs.append(songs.popleft())
    
    return result
```

## 运行示例

```python
# 测试用例1
print(solution(n = 5, a = [5, 3, 2, 1, 4]))  # 输出：[5, 2, 4, 1, 3]

# 测试用例2
print(solution(n = 4, a = [4, 1, 3, 2]))     # 输出：[4, 3, 1, 2]

# 测试用例3
print(solution(n = 6, a = [1, 2, 3, 4, 5, 6])) # 输出：[1, 3, 5, 2, 6, 4]
```

## 总结

这道题目是一个典型的队列操作问题，通过使用双端队列可以高效地实现所需的操作。关键在于：
1. 理解题目要求的播放规则
2. 选择合适的数据结构（双端队列）
3. 正确实现规则的模拟过程

对于初学者来说，建议先用纸笔模拟几个简单的例子，理解规则后再开始编码。这样可以更好地把握问题的本质，写出正确的代码。