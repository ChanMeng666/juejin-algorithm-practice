# 小M的数组变换

## 问题描述

小M拿到一个数组，她可以进行多次操作，每次操作可以选择两个元素 $a_i$ 和 $a_j$，并选择 $a_i$ 的一个因子 $x$，然后将 $a_i$ 变为 $a_i/x$，并将 $a_j$ 变为 $a_j \times x$。她的目标是通过有限次操作，使得数组中的每个元素最多只包含一种素因子。

素因子的定义是：若 $x$ 能被素数 $p$ 整除，那么 $p$ 是 $x$ 的一个素因子。例如，12 的素因子有 2 和 3。

你的任务是判断是否有可能通过有限次操作，使数组中的每个元素最多只包含一种素因子。如果可以，输出 "Yes"，否则输出 "No"。

## 问题分析

这个问题乍看起来可能有点复杂，但是如果我们仔细分析，会发现一些重要的特性：

1. 每次操作实际上是在两个元素之间转移因子，而不改变这两个元素的乘积。
2. 因此，整个数组所有元素的乘积在操作过程中保持不变。
3. 我们的目标是让每个元素最多只包含一种素因子，这意味着我们需要将不同的素因子分配到不同的元素中。

基于以上观察，我们可以得出一个重要结论：问题的可解性取决于数组所有元素乘积的不同素因子的数量是否不超过数组的长度。

## 解题思路

1. 计算数组所有元素的乘积。
2. 找出这个乘积的所有素因子。
3. 统计不同素因子的数量。
4. 如果不同素因子的数量不超过数组长度，那么问题有解，否则无解。

这个思路之所以有效，是因为：
- 如果不同素因子的数量不超过数组长度，我们总能通过操作将每种素因子分配到一个单独的元素中。
- 如果不同素因子的数量超过数组长度，那么无论如何操作，总会有至少一个元素包含多于一种素因子。

## 代码实现

以下是Python代码实现：

```python
def solution(n: int, a: list) -> str:
    def prime_factors(num):
        factors = []
        d = 2
        while num > 1:
            while num % d == 0:
                factors.append(d)
                num //= d
            d += 1
            if d * d > num:
                if num > 1:
                    factors.append(num)
                break
        return factors

    # 计算所有元素的乘积
    product = 1
    for num in a:
        product *= num

    # 找出乘积的所有素因子
    all_factors = prime_factors(product)

    # 统计不同素因子的数量
    unique_factors = set(all_factors)

    # 判断不同素因子的数量是否不超过数组长度
    if len(unique_factors) <= n:
        return "Yes"
    else:
        return "No"

if __name__ == '__main__':
    print(solution(4, [1, 2, 3, 4]) == "Yes")
    print(solution(2, [10, 12]) == "No")
    print(solution(3, [6, 9, 15]) == "Yes")
```

### 代码解释

1. `prime_factors` 函数：
   - 这个辅助函数用于找出一个数的所有素因子。
   - 它使用试除法，从2开始尝试除数，如果能整除就记录这个因子，并继续除以这个因子，直到不能整除为止。
   - 然后增加除数，继续尝试，直到除数的平方大于剩余的数。
   - 如果最后剩余的数大于1，它本身就是一个素因子。

2. 主函数 `solution`：
   - 首先计算数组所有元素的乘积。
   - 然后使用 `prime_factors` 函数找出这个乘积的所有素因子。
   - 使用 `set` 来统计不同素因子的数量，这样可以去除重复的因子。
   - 最后比较不同素因子的数量和数组长度，如果不超过则返回 "Yes"，否则返回 "No"。

## 时间和空间复杂度

- 时间复杂度：O(n + sqrt(m))，其中 n 是数组长度，m 是数组元素的乘积。计算乘积需要 O(n) 时间，而找素因子的时间复杂度约为 O(sqrt(m))。
- 空间复杂度：O(log m)，用于存储素因子。在最坏情况下，一个数的素因子数量大约是其对数级别的。

## 测试用例分析

1. 输入：`n = 4, a = [1, 2, 3, 4]`
   输出：`'Yes'`
   解释：乘积为24，素因子为2和3，数量为2，不超过数组长度4。

2. 输入：`n = 2, a = [10, 12]`
   输出：`'No'`
   解释：乘积为120，素因子为2、3和5，数量为3，超过数组长度2。

3. 输入：`n = 3, a = [6, 9, 15]`
   输出：`'Yes'`
   解释：乘积为810，素因子为2、3和5，数量为3，不超过数组长度3。

## 总结

这道题目看似复杂，但通过分析数组元素乘积的不变性，我们可以将问题转化为简单的素因子统计。这种转化思路在算法问题中很常见，也很重要。通过这道题，我们不仅学习了如何分解素因子，还了解了如何将复杂的操作序列问题转化为静态的数学问题。这种思维方式对于解决更复杂的算法问题很有帮助。