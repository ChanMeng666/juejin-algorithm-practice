# 交替上下坡路径问题

## 问题描述

小U要在一个 m×n 的地图上行走。地图中的每个位置都有一个高度值，表示该位置的海拔高度。小U的行走必须遵守以下规则：

1. 只能上坡或者下坡，不能走到高度相同的点
2. 移动必须交替进行：上坡后必须下坡，下坡后必须上坡
3. 每个位置只能经过一次，不能重复行走

要求计算出小U在地图上可以移动的最大次数。

### 示例

**示例 1:**
```
输入: m = 2, n = 2, a = [[1, 2], [4, 3]]
输出: 3
解释: 可以按照 3 -> 4 -> 1 -> 2 的顺序移动，总共移动3次
```

**示例 2:**
```
输入: m = 3, n = 3, a = [[10, 1, 6], [5, 9, 3], [7, 2, 4]]
输出: 8
```

## 解题思路

这是一个典型的DFS（深度优先搜索）问题，需要考虑以下几个关键点：

1. **状态记录**：
   - 需要记录已经访问过的位置
   - 需要记录当前是处于上坡还是下坡状态
   - 需要记录当前移动的步数

2. **搜索策略**：
   - 从每个位置都尝试作为起点
   - 每个起点都需要尝试两种开始状态：上坡和下坡
   - 在每个位置向四个方向搜索

3. **剪枝条件**：
   - 位置超出边界时停止
   - 位置已访问过时停止
   - 高度不满足上坡/下坡要求时停止

## 代码实现

```python
def solution(m: int, n: int, a: list) -> int:
    # 定义方向：上下左右
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    visited = set()
    max_steps = [0]  # 使用列表存储最大步数，方便在递归中修改
    
    def dfs(x: int, y: int, going_up: bool, steps: int):
        max_steps[0] = max(max_steps[0], steps)
        
        # 遍历四个方向
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy
            
            # 检查新位置是否有效
            if (new_x < 0 or new_x >= m or 
                new_y < 0 or new_y >= n or 
                (new_x, new_y) in visited):
                continue
            
            # 检查高度差是否符合上坡/下坡要求
            if going_up and a[new_x][new_y] <= a[x][y]:
                continue
            if not going_up and a[new_x][new_y] >= a[x][y]:
                continue
            
            # 继续搜索
            visited.add((new_x, new_y))
            dfs(new_x, new_y, not going_up, steps + 1)
            visited.remove((new_x, new_y))
    
    # 从每个位置开始尝试
    for i in range(m):
        for j in range(n):
            visited.add((i, j))
            # 分别尝试从上坡和下坡开始
            dfs(i, j, True, 0)
            dfs(i, j, False, 0)
            visited.remove((i, j))
    
    return max_steps[0]
```

## 代码详解

1. **函数参数**：
   - `m, n`: 地图的行数和列数
   - `a`: 二维数组，表示地图上每个位置的高度

2. **全局变量**：
   - `directions`: 定义四个移动方向（右、左、下、上）
   - `visited`: 使用集合记录已访问的位置
   - `max_steps`: 使用列表存储最大步数（使用列表是为了在递归中可以修改）

3. **DFS函数参数**：
   - `x, y`: 当前位置的坐标
   - `going_up`: 布尔值，表示当前是否需要上坡
   - `steps`: 当前已经移动的步数

4. **主要逻辑**：
   - 遍历地图上的每个位置作为起点
   - 对每个起点，分别尝试上坡和下坡开始
   - 在DFS过程中，根据上坡/下坡的要求选择下一个可行的位置
   - 使用回溯法，在递归返回时撤销访问标记

5. **剪枝条件**：
   - 位置越界
   - 位置已访问
   - 高度不满足上坡/下坡要求

## 复杂度分析

- 时间复杂度：O(4^(m*n))，因为每个位置都有4个方向可以选择
- 空间复杂度：O(m*n)，主要是visited集合的空间消耗和递归栈的深度

## 总结

这道题目是一个比较典型的DFS搜索问题，难点在于：
1. 需要考虑上坡下坡交替的约束
2. 需要从每个位置开始尝试
3. 需要正确处理已访问位置的标记和回溯

解决这类问题的关键是：
1. 清晰地定义搜索状态
2. 正确处理约束条件
3. 合理使用剪枝优化搜索效率

