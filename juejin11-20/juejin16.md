# 最大矩形面积问题

## 题目描述

给定一个数组 h₁, h₂, ..., hₙ，数组中的每个元素代表某种高度。我们需要在这个数组中找出任意k个相邻元素所能形成的最大矩形面积。

对于k个相邻的元素，矩形的最大面积计算公式为：
R(k) = k × min(h[i], h[i+1], ..., h[i+k-1])

其中：
- k 是选取的相邻元素个数
- min() 函数返回这k个元素中的最小值

## 示例

### 示例 1
```python
输入：n = 5, array = [1, 2, 3, 4, 5]
输出：9
解释：当选择最后三个元素[3,4,5]时，最小值是3，k=3，因此面积为3×3=9
```

### 示例 2
```python
输入：n = 6, array = [5, 4, 3, 2, 1, 6]
输出：9
```

### 示例 3
```python
输入：n = 4, array = [4, 4, 4, 4]
输出：16
解释：选择所有元素时，最小值是4，k=4，因此面积为4×4=16
```

## 解题思路

1. 这道题的关键是要考虑所有可能的相邻元素组合。我们需要：
   - 考虑所有可能的窗口大小（k从1到n）
   - 对每个窗口大小，考虑所有可能的起始位置

2. 对于每个窗口：
   - 找出窗口内的最小值
   - 计算当前窗口的矩形面积（最小值 × 窗口大小）
   - 更新全局最大面积

3. 时间复杂度分析：
   - 外层循环：O(n)
   - 内层循环：O(n)
   - 求最小值操作：O(k)
   - 总体时间复杂度：O(n³)

## 代码实现

```python
def solution(n, array):
    max_area = 0
    
    # 遍历所有可能的窗口大小k
    for k in range(1, n + 1):
        # 遍历所有可能的起始位置
        for i in range(n - k + 1):
            # 获取当前窗口中的最小值
            min_height = min(array[i:i + k])
            # 计算当前窗口的矩形面积
            area = k * min_height
            # 更新最大面积
            max_area = max(max_area, area)
    
    return max_area
```

## 代码详解

1. `max_area = 0`：初始化最大面积为0

2. 第一层循环 `for k in range(1, n + 1)`：
   - 遍历所有可能的窗口大小
   - k从1开始，最大到n（整个数组长度）

3. 第二层循环 `for i in range(n - k + 1)`：
   - 遍历所有可能的起始位置
   - `n - k + 1`确保窗口不会超出数组范围

4. `min_height = min(array[i:i + k])`：
   - 使用切片获取当前窗口内的元素
   - 计算这些元素中的最小值

5. `area = k * min_height`：
   - 计算当前窗口的矩形面积
   - 面积 = 窗口大小 × 最小高度

6. `max_area = max(max_area, area)`：
   - 更新全局最大面积
   - 如果当前面积更大，则更新max_area

## 优化思路

当前解法的时间复杂度为O(n³)，在实际应用中可能会比较慢。可以考虑以下优化方向：

1. 使用单调栈来优化求最小值的操作
2. 使用滑动窗口来维护最小值
3. 预处理数组，记录每个位置往左往右的最小值范围

这些优化可以将时间复杂度降低到O(n²)或更低。

## 总结

这道题目考察了：
1. 数组的遍历和切片操作
2. 窗口滑动的概念
3. 最大值/最小值的动态维护
4. 矩形面积的计算

对于算法初学者来说，这是一道很好的练习题，可以帮助理解数组操作和窗口滑动的概念。虽然初始解法可能不是最优的，但容易理解和实现，适合作为入门题目。

