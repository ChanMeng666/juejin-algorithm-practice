# 最小字典序字符串

## 题目描述

小U拥有一个由0和1组成的字符串，她可以进行最多k次操作，每次操作可以交换相邻的两个字符。目标是通过这些操作，使得最终得到的字符串字典序最小。

例如，小U当前有一个字符串 01010，她最多可以进行 2 次相邻字符交换操作。通过这些操作，她可以将字符串调整为 00101，这是可以通过不超过2次操作得到的字典序最小的字符串。

## 输入格式
- n：字符串长度
- k：最多可进行的交换操作次数
- s：初始字符串

## 输出格式
返回经过最多k次操作后能够得到的字典序最小的字符串。

## 示例
```python
输入：n = 5, k = 2, s = "01010"
输出：'00101'

输入：n = 7, k = 3, s = "1101001"
输出：'0110101'

输入：n = 4, k = 1, s = "1001"
输出：'0101'
```

## 解题思路

这是一个贪心算法问题。我们需要在有限的k次操作中，尽可能地将字符'0'移到字符串的前面，以获得字典序最小的字符串。

关键思路：
1. 从左到右遍历字符串的每个位置
2. 对于每个位置，在当前位置后面k步以内寻找'0'
3. 如果找到'0'，就将它通过相邻交换移动到当前位置
4. 每次移动后更新剩余的可操作次数

## 代码实现

```python
def solution(n: int, k: int, s: str) -> str:
    # 将字符串转换为列表以便修改
    s = list(s)
    remaining_moves = k
    
    # 遍历字符串的每个位置
    for i in range(n):
        if remaining_moves == 0:
            break
            
        # 找到当前位置后最近的0
        min_pos = i
        for j in range(i + 1, min(i + remaining_moves + 1, n)):
            if s[j] == '0':
                min_pos = j
                break
        
        # 如果找到了0，将它移动到当前位置
        if min_pos != i and s[min_pos] == '0':
            # 计算需要的移动次数
            moves_needed = min_pos - i
            if moves_needed <= remaining_moves:
                # 将0向前移动到位置i
                for j in range(min_pos, i, -1):
                    s[j], s[j-1] = s[j-1], s[j]
                remaining_moves -= moves_needed
    
    return ''.join(s)
```

## 代码详解

1. **初始化**：
   - 将输入字符串转换为列表，方便进行字符交换操作
   - 使用remaining_moves记录剩余可用的操作次数

2. **主循环**：
   - 从左到右遍历字符串的每个位置i
   - 如果已经没有剩余操作次数，则退出循环

3. **查找最近的'0'**：
   - 在当前位置之后、可达范围内(i + remaining_moves + 1)查找最近的'0'
   - 记录找到的'0'的位置min_pos

4. **移动操作**：
   - 如果找到了'0'且位置不是当前位置：
     - 计算需要的移动次数moves_needed
     - 如果moves_needed不超过剩余操作次数：
       - 通过连续的相邻交换将'0'移动到位置i
       - 更新剩余操作次数

5. **返回结果**：
   - 将处理后的列表转换回字符串并返回

## 复杂度分析

- 时间复杂度：O(n*k)，其中n是字符串长度，k是最大操作次数
- 空间复杂度：O(n)，需要将字符串转换为列表

## 题目提示
1. 注意检查剩余操作次数是否足够进行移动
2. 每次都选择可达范围内最近的'0'进行移动
3. 不要忘记更新剩余操作次数
4. 考虑特殊情况：k=0或字符串已经是最优的情况
